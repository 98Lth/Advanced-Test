下面是来自著名美国大学`卡内基梅隆大学`的介绍软件测试，从事软测行业，我觉得有必要了解一下。
英语不好强行提笔，文中有不对的地方，请指正，谢谢

英语好的同学，可以直接看下面的原文链接
>https://users.ece.cmu.edu/~koopman/des_s99/sw_testing/


软件测试是任何旨在评估一个程序或系统的属性或能力并确定它满足其所需结果的活动。 尽管软件测试对软件质量至关重要，并且被程序员和测试人员广泛使用，但由于对软件原理的理解有限，软件测试仍然是一门艺术。 软件测试的困难源于软件的复杂性: 我们不能完全测试一个中等复杂度的程序。 测试不仅仅是调试。 测试的目的可以是质量保证、验证及确认或可靠性评估。 测试也可以作为一种通用度量。 正确性测试和可靠性测试是测试的两个主要领域。 软件测试是预算、时间和质量之间的权衡。



软件测试是为了发现错误而执行程序或系统的过程。 [ Myers79]或者，它包括任何旨在评估一个程序或系统的属性或能力并确定它满足所需结果的活动。 [ Hetzel88]软件与其他物理过程不同，在这些过程中，输入被接收，输出被生成。 软件的不同之处在于它失败的方式。 大多数物理系统都以固定(且相当小)的方式出现故障。 相比之下，软件可能以许多奇怪的方式失败。 检测所有不同的软件故障模式通常是不可行的。 [ Rstcorp ]

与大多数物理系统不同，软件中的大多数缺陷是设计错误，而不是制造缺陷。 软件不会遭受腐蚀、磨损——通常直到升级或者过时，它才会改变。 因此，一旦软件发货，设计缺陷——或者说 bug ——将被隐藏起来，直到激活为止。


# 前言

软件缺陷几乎总是存在于任何大小适中的软件模块中: 不是因为程序员粗心或不负责任，而是因为软件的复杂性通常是难以处理的---- 而且人类只有有限的能力来管理复杂性。 对于任何复杂的系统，设计缺陷也不能完全排除。

发现软件中的设计缺陷，同样是困难的，因为同样的复杂性。 由于软件和任何数字系统都是不连续的，测试边界值不足以保证正确性。 所有可能的值都需要测试和验证，但是完整的测试是不可行的。 尽可能详尽地测试一个只添加两个32位整数输入的简单程序(产生2 ^ 64个不同的测试用例)需要数百年的时间，即使测试以每秒数千次的速度进行。 显然，对于一个实际的软件模块，其复杂性可能远远超过这里提到的示例。 如果涉及到来自现实世界的输入，问题将变得更糟，因为时间和不可预测的环境影响以及人与人之间的相互作用都是正在考虑的可能输入参数。

进一步的复杂性与程序的动态性有关。 如果在初步测试期间发生了故障，并且代码被更改，那么软件现在可以为一个以前不能使用的测试用例工作。 但是，它在以前通过的预错误测试用例上的行为不再能够得到保证。 为了考虑到这种可能性，应该重新启动测试。 这样做的费用往往令人望而却步。 [ Rstcorp ]



一个有趣的类比将软件测试的困难与杀虫剂的困难相提并论，即所谓的杀虫剂悖论[ Beizer90] : 你用来防止或发现虫子的每一种方法都会留下一些微妙的虫子残留物，而这些方法对这些虫子是无效的。 但是这并不能保证使软件变得更好，因为“复杂性障碍”(Complexity Barrier [ Beizer90])原则指出: 软件复杂性(以及因此而产生的 bug)已经达到了我们管理这种复杂性的能力的极限。 通过消除(以前的)容易的 bug，您允许特性和复杂性的另一个升级，但是他的时间您有更微妙的 bug 面对，只是为了保持您以前拥有的可靠性。 社会似乎不愿意限制复杂性，因为我们都想要额外的铃声、哨子和功能互动。 因此，我们的用户总是把我们推向复杂的障碍，而我们能够接近这个障碍的程度在很大程度上取决于我们对付更复杂和微妙的错误所运用的技术的强度。 [ Beizer90]



尽管有这些限制，测试仍然是软件开发中不可或缺的一部分。 它被广泛地部署在软件开发周期的每个阶段。 通常，超过50% 的开发时间用于测试。 测试通常用于以下目的:

## 提高质量


由于计算机和软件被用于关键的应用程序，故障的后果可能是严重的。 缺陷可以造成巨大的损失。 关键系统的缺陷导致了飞机失事，航天飞机任务出了差错，股票市场停止交易，甚至更糟。 虫子会杀人。 虫子会引起灾难。 所谓的2000年问题催生了一个由顾问和编程工具组成的家庭手工业，致力于确保现代世界不会在下个世纪的第一天戛然而止。 [ bug ]在一个计算机化的嵌入式世界里，软件的质量和可靠性是生死攸关的问题。



质量是指符合规定的设计要求。 正确是对质量的最低要求，是指在特定情况下按要求执行。 调试是软件测试的一个狭隘的视角，程序员通过大量的调试来发现设计缺陷。 人性的不完美使得一个中等复杂的程序几乎不可能在第一时间进行修正。 发现问题并解决问题[ Kaner93] ，是编程阶段调试的目的。

正如主题验证及确认所指出的，测试的另一个重要目的是验证及确认。 测试可以作为度量标准。 在 v & v 过程中，它被大量用作工具。 测试人员可以根据对测试结果的解释作出声明，产品可以在某些情况下工作，也可以不工作。 我们也可以根据相同的测试结果，比较同一规格的不同产品之间的质量。


我们不能直接检测质量，但我们可以检测相关因素，使质量可见。 质量有三组因素——功能性、工程性和适应性。 这三组因素可以看作是软件质量空间中的维度。 每个维度可以在依次较低的细节层次上分解为其组成因素和考虑因素。 表1说明了一些最常被引用的质量考虑因素。


 ### 典型的软件质量因素
| Functionality (exterior quality) 功能(外观质量)| 	Engineering (interior quality) 工程(室内质量)| 	Adaptability (future quality) 适应性(未来质量)| 
|  ----  | ----  | ----  |
Correctness 正确性| 	Efficiency 效率| 	Flexibility 灵活性
Reliability 可靠性| 	Testability 可测试性| 	Reusability 可重用性
Usability 可用性	| Documentation 文件| 	Maintainability 可维护性
Integrity 诚信	| Structure 结构	| 



良好的测试为所有相关因素提供了衡量标准。 任何特定因素的重要性因应用而异。 任何涉及人类生命安全的系统都必须极其强调可靠性和完整性。 在典型的业务系统中，可用性和可维护性是关键因素，而对于一个一次性的科学程序来说，可用性和可维护性并不重要。 我们的测试，为了完全有效，必须面向衡量每个相关因素，从而迫使质量成为有形和可见的。 [赫泽尔88]


用于验证产品工作的测试称为干净测试或阳性测试。 缺点是，它只能验证软件是否为指定的测试用例工作。 有限数量的测试无法验证软件是否适用于所有情况。 相反，只有一个失败的测试就足以证明软件不能工作。 肮脏测试，或者说是否定测试，指的是那些旨在破坏软件的测试，或者表明软件不能正常工作的测试。 一个软件必须具有足够的异常处理能力，才能在重要级别的脏测试中生存下来。



可测试的设计是一种易于验证、伪造和维护的设计。 由于测试是一项严格的工作，需要大量的时间和成本，因此可测试性设计也是软件开发的一个重要设计规则。


软件可靠性与软件的许多方面有着重要的关系，包括软件的结构以及软件所受到的测试量。 基于运行剖面(对程序各种输入使用的相对频率的估计[ Lyu95]) ，测试可以作为一种统计抽样方法，获取故障数据进行可靠性估计。


软件测试还不成熟。 它仍然是一门艺术，因为我们仍然不能把它变成一门科学。 我们仍在使用20-30年前发明的同样的测试技术，其中一些是精心设计的方法或启发式方法，而不是好的工程方法。 软件测试成本可能很高，但不测试软件则更加昂贵，尤其是在人类生命处于危险之中的地方。 解决软件测试问题并不比解决图灵停机问题容易。 我们永远无法确定一个软件是否正确。 我们永远无法确定这些规格是否正确。 没有任何验证系统可以验证每一个正确的程序。 我们也永远无法确定一个验证系统是否正确。

# 关键概念
##  分类学

有过多的测试方法和测试技术，在不同的生命周期阶段服务于多种用途。 软件测试按目的分为: 正确性测试、性能测试、可靠性测试和安全性测试。 按生命周期阶段划分，软件测试可分为需求阶段测试、设计阶段测试、程序阶段测试、评估测试结果、安装阶段测试、验收测试和维护测试。 按照范围，软件测试可以分为以下几类: 单元测试、组件测试、集成测试和系统测试。

## 正确性测试


正确性是软件的最低要求，是测试的基本目的。 正确性测试将需要某种类型的 oracle，以区分正确的行为和错误的行为。 测试人员可能知道也可能不知道被测试软件模块的内部细节，例如控制流程、数据流程等。 因此，在测试软件时可以采用白盒视角或黑盒视角。 我们必须注意，黑盒和白盒思想并不仅限于正确性测试。

##  黑盒测试


黑盒方法是一种测试方法，其中测试数据来自于指定的功能需求，而不考虑最终的程序结构。 它也称为数据驱动、输入 / 输出驱动[ Myers79]或基于需求的[ Hetzel88]测试。 因为只有软件模块的功能是需要关注的，黑盒测试也主要指功能测试---- 一种强调执行功能和检查输入输出数据的测试方法。 [ Howden87]测试人员将被测试的软件视为一个黑盒子——只有输入、输出和规范是可见的，而功能是通过观察相应输入的输出来确定的。 在测试中，执行各种输入，并将输出与规范进行比较，以验证其正确性。 所有测试用例都是从规范中派生出来的。 不考虑代码的实现细节。



很明显，我们在输入空间中覆盖的内容越多，我们将发现越多的问题，因此我们将对软件的质量更有信心。 理想情况下，我们应该尽可能详尽地测试输入空间。 但是如上所述，对于大多数程序来说，用尽全力测试有效输入的组合是不可能的，更不用说考虑无效的输入、时间、顺序和资源变量了。 组合爆炸是功能测试的主要障碍。 更糟糕的是，我们永远无法确定这个规范是正确的还是完整的。 由于规范语言(通常是自然语言)的局限性，歧义往往是不可避免的。 即使我们使用某种类型的正式或受限制的语言，我们仍然可能无法写出规范中所有可能的情况。 有时，规范本身成为一个棘手的问题: 不可能用有限的词语精确地指定可能遇到的每一种情况。 人们很少能够清楚地说明他们想要什么---- 他们通常能够在完成之后分辨出一个原型是否是他们想要的。 规范问题导致了软件中大约30% 的错误。 [ Beizer95]



黑盒测试的研究主要集中在如何以最小的代价最大化测试的有效性，通常是测试用例的数量。 不可能用尽输入空间，但可以用尽输入空间的子集。 分区是常用的技术之一。 如果我们已经将输入空间分区，并且假设一个分区中的所有输入值都是等价的，那么我们只需要在每个分区中测试一个代表值，以充分覆盖整个输入空间。 域测试[ Beizer95]将输入域划分为多个区域，并将每个区域中的输入值视为一个等价类。 域可以通过选择每个域中的代表值进行详尽的测试和覆盖。 边界值是特别重要的。 经验表明，探索边界条件的测试用例比不探索边界条件的测试用例有更高的回报。 边界值分析[ Myers79]需要选择一个或多个边界值作为典型的测试用例。 域测试的困难在于无法有效地发现规范中不正确的域定义。



良好的分区需要软件结构知识。 一个好的测试计划不仅包括黑盒测试，还包括白盒方法，以及两者的结合。

## 白盒测试


与黑盒测试相反，软件被看作是一个白盒子，或者说是白盒测试中的玻璃盒子，因为被测试软件的结构和流程对测试人员来说是可见的。 测试计划是根据软件实现的细节制定的，例如编程语言、逻辑和样式。 测试用例来源于程序结构。 白盒测试测试也被称为玻璃盒测试，逻辑驱动测试[ Myers79]或基于设计的测试[ Hetzel88]。



在21白盒测试有许多可用的技术，因为对测试软件结构的特定知识和关注缓解了棘手的问题。 用尽软件某些方面的意图在21白盒测试仍然很强烈，并且可以达到某种程度的用尽，例如每行代码至少执行一次(语句覆盖率) ，遍历每个分支语句(分支覆盖率) ，或者覆盖所有真假条件谓词的可能组合(多条件覆盖率)。 [ Parrington89]



控制流测试、循环测试和数据流测试都将相应的软件流结构映射到有向图中。 根据至少覆盖或遍历所有节点或路径一次的标准，谨慎地选择测试用例。 通过这样做，我们可能会发现不必要的“死”代码——没有用处的代码，或者根本不执行的代码，功能测试无法发现这些代码。


在突变测试，原始的程序代码被扰乱，许多突变的程序被创建，每个都包含一个错误。 程序的每个错误版本都被称为变种。 测试数据是根据失败的突变体的有效性来选择的。 测试用例杀死的突变体越多，测试用例被考虑的效果就越好。 突变测试的问题在于它太昂贵了以至于无法使用。 黑盒方法和白盒方法之间的界限并不明确。 上面提到的许多测试策略，可能不能安全地分为黑盒测试或白盒测试。 对于事务流测试、语法测试、有限状态测试和许多其他本文没有讨论的测试策略也是如此。 原因之一是，上述所有技术都需要一些关于被测试软件规范的知识。 另一个原因是规范本身的概念很广泛——它可能包含任何需求，包括结构、编程语言和编程风格作为规范内容的一部分。



我们可能不愿意把随机测试看作是一种测试技术。 测试用例的选择简单而直接: 它们是随机选择的。 [ Duran84]的研究表明，随机测试对许多程序来说更具成本效益。 一些非常微妙的错误可以以很低的成本被发现。 而且它的覆盖率也不比其他精心设计的测试技术差。 人们也可以利用基于操作剖面的随机试验结果获得可靠性估计。 将随机测试与其他测试技术有效地结合起来，可以产生更强大和更经济有效的测试策略。


## 性能测试


并非所有的软件系统都有明确的性能规范。 但是每个系统都有隐含的性能需求。 软件不应该花费无限的时间或无限的资源来执行。 “性能缺陷”有时用来指那些导致系统性能下降的软件设计问题。


性能一直是计算机发展的重点和推动力。 软件系统的性能评价通常包括: 资源使用、吞吐量、刺激响应时间和队列长度，它们详细描述了选定资源等待服务的平均或最大任务数量。 需要考虑的典型资源包括网络带宽需求、 CPU 周期、磁盘空间、磁盘访问操作和内存使用[ Smith90]。 性能测试的目标可以是性能瓶颈识别、性能比较和评价等。 进行性能测试的典型方法是使用基准测试——一个代表典型系统使用情况的程序、工作负载或跟踪。 [ vokoolos98]

## 可靠性测试


软件可靠性是指系统无故障运行的概率。 它涉及到软件的许多方面，包括测试过程。 通过量化软件可靠性的相关因素直接评估软件可靠性是困难的。 测试是度量软件可靠性的一种有效的抽样方法。 在操作剖面的指导下，软件测试(通常是黑盒测试测试)可以用来获得故障数据，并且可以进一步使用估计模型来分析数据以估计当前的可靠性和预测未来的可靠性。 因此，开发人员可以根据评估结果决定是否发布软件，用户可以决定是否采用和使用软件。 使用软件的风险也可以基于可靠性信息进行评估。 [ Hamlet94]主张测试的主要目标应该是测量被测试软件的可靠性。



人们对可靠软件的直观含义达成了一致: 它不会以意想不到的或灾难性的方式失败。 [ Hamlet94]稳健性试验和应力试验是基于这一简单准则的可靠性试验的方差。



基于组件的软件工程系统的鲁棒性是它在特殊输入或紧张的环境条件下能够正常工作的程度。 [ IEEE90]稳健性测试与正确性测试的不同之处在于，它不关心软件的功能正确性。 它只关注诸如机器崩溃、进程挂起或异常终止等健壮性问题。 Oracle 相对简单，因此健壮性测试可以比正确性测试更具可移植性和可扩展性。 这项研究最近引起了越来越多的兴趣，其中大多数都以商业操作系统为目标，例如[ Koopman97][ Kropp98][ Ghosh98][ devalos 99][ Koopman99]。


压力测试，或负载测试，通常用于测试整个系统，而不仅仅是测试软件。 在这种测试中，软件或系统的运行受到或超过了规定的限制。 典型的压力包括资源枯竭、突发性活动和持续的高负荷。

 ## 安全测试


软件质量、可靠性和安全性是紧密耦合的。 入侵者可以利用软件中的漏洞打开安全漏洞。 随着互联网的发展，软件安全问题越来越严重。



许多关键的软件应用程序和服务都集成了针对恶意攻击的安全措施。 对这些系统进行安全测试的目的包括识别和消除可能导致安全违规的软件缺陷，以及验证安全措施的有效性。 可以执行模拟的安全攻击来发现漏洞。

## 测试自动化


软件测试可能非常昂贵。 自动化是减少时间和成本的好方法。 软件测试工具和技术通常缺乏通用的适用性和可伸缩性。 原因很简单。 为了使这个过程自动化，我们必须有一些方法来从规范中生成预言，并生成测试用例来测试目标软件以确定它们的正确性。 今天，我们仍然没有一个完整的系统来实现这个目标。 一般来说，在测试中仍然需要大量的人工干预。 自动化程度保持在自动化测试脚本级别。



在可靠性测试和性能测试中，这一问题有所缓解。 在健壮性测试中，简单的规范和 oracle: 不崩溃，不挂起就足够了。 类似的简单度量也可以用于压力测试。

## 什么时候停止测试？


测试可能是无穷无尽的。 我们不能测试，直到所有的缺陷都被发现和消除——这是根本不可能的。 在某种程度上，我们必须停止测试并发布软件。 问题是什么时候。


实际上，测试是预算、时间和质量之间的权衡。 它是由盈利模式驱动的。 最悲观的，也是最不幸的是最常用的方法是，当一些或任何分配的资源——时间、预算或测试用例——用尽时停止测试。 最乐观的停止规则是，当可靠性满足要求或者继续测试的好处不能证明测试成本合理时停止测试。 [ Yang95]这通常需要使用可靠性模型来评估和预测被测试软件的可靠性。 每个评估都需要重复运行以下循环: 故障数据收集 -- 建模 -- 预测。 然而，这种方法不适用于超可靠系统，因为实际的现场故障数据需要很长时间才能积累。

## 测试的替代品


软件测试越来越多地被认为是一种有问题的方法，以获得更好的质量。 使用测试来定位和纠正软件缺陷可能是一个无止境的过程。 虫子是不能完全排除的。 正如复杂性障碍表明的那样: 测试和修复问题的机会并不一定会提高软件的质量和可靠性。 有时修复一个问题可能会给系统带来更严重的问题，比如1991年加利福尼亚州和美国东岸电力公司的电话故障。 灾难发生在信令系统更换3行代码之后。


从狭义的角度来看，许多测试技术可能存在缺陷。 例如，覆盖测试。 测试中的代码覆盖率、分支覆盖率真的与软件质量有关吗？ 没有确切的证据。 早在[ Myers79] ，所谓的“人体试验”——包括检查、排查、评论——就被建议作为传统试验方法的可能替代方法。 [ Hamlet94]主张将检查作为单元测试的一种成本效益替代方法。 [ Basili85]中的实验结果表明，就观察到的故障数量和代价而言，分步抽象的代码读取至少与在线功能测试和结构测试一样有效。



用形式化的方法“证明”软件的正确性也是一个引人注目的研究方向。 但这种方法也不能克服复杂性的障碍。 对于相对简单的软件，这种方法很有效。 它不能很好地扩展到那些复杂的、成熟的大型软件系统，这些软件系统更容易出错。



从更广泛的角度来看，我们可能会开始质疑测试的最大目的。 为什么我们需要更有效的测试方法呢，因为发现缺陷并消除它们并不一定会带来更好的质量。 这个问题的类比就像汽车制造过程。 在工艺时代，我们制造汽车，去除问题和缺陷。 但随着流水线生产和高质量的工艺流程，这些方法被淘汰了，使得汽车在生产阶段无缺陷。 这表明，通过设计过程(如无尘室软件工程)使产品具有较少的缺陷，可能比通过设计测试过程更有效。 测试只用于质量监控和管理，或者“可测试性设计”。 这是软件从工艺到工程的飞跃。

## 可用的工具、技术和指标


有大量的软件测试工具存在。 正确性测试工具往往是针对某些系统的，它们的能力和通用性有限。 健壮性和压力测试工具更有可能成为通用工具。


Mothora [ DeMillo91]是突变测试普渡大学研发的一种自动化工具集。 使用 Mothora，测试人员可以创建和执行测试用例，测量测试用例的充分性，确定输入输出正确性，定位和删除错误或 bug，并控制和记录测试。

 它们是运行时检查和调试辅助工具。 它们可以检查和防止内存泄漏和指针问题。



Ballista COTS 软件健壮性测试线束[ Ballista99]。 Ballista 测试工具是一个全面的自动健壮性测试工具。 第一个版本支持在 UNIX 操作系统中测试多达233个 POSIX 函数调用。 第二个版本还支持测试用户函数，前提是测试服务器能够识别数据类型。 Ballista 测试工具提供了跨操作系统的健壮性比较的定量度量。 目标是针对健壮性故障自动测试和强化商用现成软件(Commercial off-The-shelf，COTS)。

 
# 结论
软件测试是一门艺术。 大多数的测试方法和实践与20年前没有太大的不同。 
虽然有许多工具和技术可供使用，但它还远远不够成熟。 
好的测试还需要测试人员的创造力、经验和直觉，以及适当的技术. 
测试不仅仅是调试。 测试不仅用于定位缺陷并纠正它们。 
它也用于验证，验证过程和可靠性测量. 测试是昂贵的。 自动化是降低成本和时间的好方法。 
测试效率和有效性是基于覆盖率的测试技术的标准. 完整的测试是不可行的。 复杂性是问题的根源。 
在某种程度上，软件测试必须停止，产品必须发货。 停车时间可以通过时间和预算的权衡来决定。 或者软件产品的可靠性估计是否满足要求,测试可能不是提高软件质量的最有效方法。 
其他的方法，如检查和无尘室工程，可能会更好.



 
